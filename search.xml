<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python-NO-5</title>
    <url>/2020/10/15/python-NO-5/</url>
    <content><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ul>
<li>变量可以指向函数</li>
<li>函数名也是变量    </li>
</ul>
<p>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</p>
<h3 id="map-函数"><a href="#map-函数" class="headerlink" title="map()函数"></a>map()函数</h3><p>根据提供的函数对指定序列做映射<br><code>map(function, iterable, ...)</code></p>
<ul>
<li>function – 函数</li>
<li>iterable – 一个或多个序列   </li>
</ul>
<h3 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce()函数"></a>reduce()函数</h3><p>对参数序列中元素进行累积<br><code>reduce(function, iterable[, initializer])</code></p>
<ul>
<li>function – 函数，有两个参数</li>
<li>iterable – 可迭代对象</li>
<li>initializer – 可选，初始参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line"></span><br><span class="line">DIGITS &#x3D; &#123;&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9&#125;</span><br><span class="line"></span><br><span class="line">def str2int(s):</span><br><span class="line">    def fn(x, y):</span><br><span class="line">        return x * 10 + y</span><br><span class="line">    def char2num(s):</span><br><span class="line">        return DIGITS[s]</span><br><span class="line">    return reduce(fn, map(char2num, s))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-NO-4</title>
    <url>/2020/10/05/python-NO-4/</url>
    <content><![CDATA[<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p><strong>取一个list或tuple的部分元素</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack&#39;]</span><br><span class="line">L[0:3]  #从索引0开始取，直到索引3为止，但不包括索引3</span><br><span class="line">L[:3]   #索引是0，可以省略</span><br><span class="line">L[-2:-1]  #索引倒数第2个，到倒数第1个，倒数第一个元素的索引是-1</span><br><span class="line">L[::5]   #所有数，每5个取一个</span><br><span class="line">L[:]   #原样复制一个</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p><strong>遍历我们称为迭代</strong><br><strong>可迭代对象:</strong> 通过collections模块的Iterable类型判断      </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line">isinstance(&#39;abc&#39;, Iterable) # str是否可迭代</span><br><span class="line">isinstance([1,2,3], Iterable) # list是否可迭代</span><br></pre></td></tr></table></figure>

<p>Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):</span><br><span class="line">...     print(i, value)</span><br><span class="line">...</span><br><span class="line">0 A</span><br><span class="line">1 B</span><br><span class="line">2 C</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>创建list的生成式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[1x1, 2x2, 3x3, ..., 10x10]</span><br><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>

<p>for循环后面还可以加上if判断，if是一个筛选条件，不能带else</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 &#x3D;&#x3D; 0]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure>
<p>for前面的if … else是表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [x if x % 2 &#x3D;&#x3D; 0 else -x for x in range(1, 11)]</span><br><span class="line">[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]</span><br></pre></td></tr></table></figure>
<p>使用两层循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</span><br><span class="line">[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>一边循环一边计算的机制，称为生成器，保存的是算法。<br>函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#斐波拉契数列 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</span><br><span class="line">def fib(max):</span><br><span class="line">    n, a, b &#x3D; 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b &#x3D; b, a + b</span><br><span class="line">        n &#x3D; n + 1</span><br><span class="line">    return &#39;done&#39;</span><br></pre></td></tr></table></figure>
<p>生成器函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个生成器</span><br><span class="line">def fib(max):    </span><br><span class="line">    n, a, b &#x3D; 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b &#x3D; b, a + b</span><br><span class="line">        n &#x3D; n + 1</span><br><span class="line">    return &#39;done&#39;</span><br><span class="line">#在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h2 id="访问集合元素的一种方式，是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。"><a href="#访问集合元素的一种方式，是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。" class="headerlink" title="访问集合元素的一种方式，是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。"></a>访问集合元素的一种方式，是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</h2><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>iter()</td>
<td>创建迭代器对象</td>
</tr>
<tr>
<td>next()</td>
<td>输出迭代器的下一个元素</td>
</tr>
</tbody></table>
<hr>
<p>凡是可作用于for循环的对象都是可迭代对象;<br>凡是可作用于next()函数的对象都是迭代器;</p>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-NO-3</title>
    <url>/2020/10/04/python-NO-3/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>所有函数见<a href="https://docs.python.org/3/library/functions.html#abs" target="_blank" rel="noopener">官方网站文档</a></p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def 函数名():</span><br><span class="line">    函数体</span><br><span class="line">    return</span><br></pre></td></tr></table></figure>
<h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><p>一个什么事也不做的空函数，可以用<code>pass</code>语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def 函数名():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ol>
<li><p>函数执行完毕也没有return语句时，自动return None。</p>
</li>
<li><p>函数可以同时返回多个值，但其实就是一个tuple</p>
</li>
</ol>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ol>
<li><p>位置参数：调用函数时根据函数定义的参数位置来传递参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(x, n):   #用来计算xn ;x,n都为位置参数</span><br><span class="line"> s &#x3D; 1</span><br><span class="line"> while n &gt; 0:</span><br><span class="line">     n &#x3D; n - 1</span><br><span class="line">     s &#x3D; s * x</span><br><span class="line"> return s</span><br></pre></td></tr></table></figure></li>
<li><p>默认参数：为参数提供默认值，调用函数时可传可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(x, n&#x3D;2):  #默认计算x2</span><br><span class="line">  s &#x3D; 1</span><br><span class="line">  while n &gt; 0:</span><br><span class="line">    n &#x3D; n - 1</span><br><span class="line">    s &#x3D; s * x</span><br><span class="line">  return s</span><br></pre></td></tr></table></figure>
<p> <em>默认参数必须指向不变对象</em></p>
</li>
<li><p>可变参数：可变参数就是传入的参数个数是可变的。可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def calc(*numbers): #*号代表可变参数</span><br><span class="line">  sum &#x3D; 0</span><br><span class="line">  for n in numbers:</span><br><span class="line">    sum &#x3D; sum + n * n</span><br><span class="line">  return sum</span><br></pre></td></tr></table></figure>
<p><code>*tuple</code>号可将list或tuple转为可变参数</p>
</li>
<li><p>关键参数：关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。<strong>作用：*</strong>可以扩展函数的功能*</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, **kw):  #**号表示关键字参数</span><br><span class="line"> print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)</span><br></pre></td></tr></table></figure>
<p><code>**dict</code>可将dict的所有key-value用关键字参数传入</p>
</li>
<li><p>命名关键字参数:限制关键字参数的名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, *, city, job):   #命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数</span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure>

<p><em>缺少<code>*</code>，city和job被视为位置参数</em></p>
</li>
<li><p>参数组合：参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f1(a, b, c&#x3D;0, *args, **kw):</span><br><span class="line">  print(&#39;a &#x3D;&#39;, a, &#39;b &#x3D;&#39;, b, &#39;c &#x3D;&#39;, c, &#39;args &#x3D;&#39;, args, &#39;kw &#x3D;&#39;, kw)</span><br><span class="line"></span><br><span class="line">def f2(a, b, c&#x3D;0, *, d, **kw):</span><br><span class="line">  print(&#39;a &#x3D;&#39;, a, &#39;b &#x3D;&#39;, b, &#39;c &#x3D;&#39;, c, &#39;d &#x3D;&#39;, d, &#39;kw &#x3D;&#39;, kw)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>一个函数在内部调用自身本身，这个函数就是递归函数。    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  阶乘</span><br><span class="line">def fact(n):</span><br><span class="line">    if n&#x3D;&#x3D;1:</span><br><span class="line">        return 1</span><br><span class="line">    return n * fact(n - 1)</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">**栈：** 函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧   </span><br><span class="line">**尾递归优化：** *解决递归调用栈溢出*</span><br></pre></td></tr></table></figure>
<p>def fact(n):<br>    return fact_iter(n, 1)</p>
<p>def fact_iter(num, product):<br>    if num == 1:<br>        return product<br>    return fact_iter(num - 1, num * product)   #返回递归函数本身</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## 说明</span><br></pre></td></tr></table></figure>
<p>from 文件名 import 函数名</p>
<pre><code></code></pre>]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-NO-2</title>
    <url>/2020/09/15/python-NO-2/</url>
    <content><![CDATA[<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if &lt;条件1&gt;：</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif&lt;条件2&gt;：</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行3&gt;</span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li><code>for x in ... :</code></li>
<li>while循环<ul>
<li>break 提前结束循环</li>
<li>continue 提前结束本轮循环，并直接开始下一轮循环</li>
</ul>
</li>
</ul>
<h2 id="dict-字典"><a href="#dict-字典" class="headerlink" title="dict 字典"></a>dict 字典</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;a:1,b:2,c:3&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>get()</code></td>
<td>返回key</td>
<td><code>d.get(&#39;Thomas&#39;)</code></td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>删除key</td>
<td><code>d.pop(&#39;Bob&#39;)</code></td>
</tr>
</tbody></table>
<p>和list比较，dict有以下几个特点：</p>
<ol>
<li>dict查找和插入的速度极快，不会随着key的增加而变慢；需要占用大量的内存，内存浪费多。</li>
<li>而list相反：查找和插入的时间随着元素的增加而增加；占用空间小，浪费内存很少。</li>
<li>dict 的key不可变类型。ps:字符串、整数等都是不可变的,list是可变的</li>
</ol>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set和dict的唯一区别仅在于没有存储对应的value;要创建一个set，需要提供一个list作为输入集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>add()</code></td>
<td>添加元素</td>
<td><code>s.add(4)</code>ps:可以重复添加，但不会有效果</td>
</tr>
<tr>
<td><code>remove()</code></td>
<td>删除元素</td>
<td><code>s.remove(4)</code></td>
</tr>
</tbody></table>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>rang ()</code></td>
<td>生成一个整数有序数列</td>
<td><code>range(5)</code>生成的序列是从0开始小于5的整数</td>
</tr>
<tr>
<td><code>list()</code></td>
<td>转化成list</td>
<td><code>list(1,2,3,4,5)</code>转化为<code>[1,2,3,4,5]</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于七星小区停车费-20200914</title>
    <url>/2020/09/14/%E5%85%B3%E4%BA%8E%E4%B8%83%E6%98%9F%E5%B0%8F%E5%8C%BA%E5%81%9C%E8%BD%A6%E8%B4%B9-20200914/</url>
    <content><![CDATA[<h1 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h1><ol>
<li>谁发布，谁收费，未明确主体；</li>
<li>车位所有权属于业主，物业违反《物权法》，未经过2/3业主同意；</li>
<li>具体的措施在哪里，不能只是以规范小区停车秩序这八字</li>
</ol>
<h1 id="伤心的事："><a href="#伤心的事：" class="headerlink" title="伤心的事："></a>伤心的事：</h1><p>  明明有法可依，还要被所有人说错的人是我。作为一个快30的人，上有父母，下有儿子，老父母觉得我给他们丢人了，可明明错的不是我，可悲。想到我家可乐长大以后还要生活在这个社会里，可悲。法制社会在哪里？为了儿子，我想我应该要做点什么。</p>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>python No.1</title>
    <url>/2020/09/13/python-No-1/</url>
    <content><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h1><ul>
<li>当语句以冒号:结尾时，缩进的语句视为代码块,使用4个空格的缩进;</li>
<li>Python程序是大小写敏感的;</li>
<li>Python允许在数字中间以 <code>_</code> 分隔;</li>
<li>用全部大写的变量名表示常量只是一个习惯上的用法</li>
<li>内存中Unicode，存储用UTF-8</li>
<li>无法显示为ASCII字符的字节，用<code>\x##</code>显示</li>
<li>转意，用<code>%%</code>来表示一个<code>%</code></li>
<li>f-string ,以f开头的字符串以对应的变量替换</li>
</ul>
<h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><ul>
<li><code>//</code>  地板除；</li>
<li><code>%</code>   取余数；</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>ord()</code></td>
<td>获取字符的整数表示</td>
</tr>
<tr>
<td><code>chr()</code></td>
<td>把编码转换为对应的字符</td>
</tr>
<tr>
<td><code>encode()</code></td>
<td>编码为指定的bytes</td>
</tr>
<tr>
<td><code>decode()</code></td>
<td>将bytes变为字符,传入参数<code>errors=&#39;ignore&#39;</code>可忽略错误的字节</td>
</tr>
<tr>
<td><code>len()</code></td>
<td>计算字符串包含多少个字符或字节数</td>
</tr>
<tr>
<td><code>format()</code></td>
<td>用传入的参数依次替换字符串内的占位符{0}、{1}</td>
</tr>
</tbody></table>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><table>
<thead>
<tr>
<th>占位符</th>
<th>替换内容</th>
</tr>
</thead>
<tbody><tr>
<td><code>%d</code></td>
<td>整数</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>浮点数</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>十六进制整数</td>
</tr>
</tbody></table>
<h2 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple"></a>list和tuple</h2><ol>
<li><code>list</code>是一个可变的有序数表,<code>[a,b,c]</code><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>append()</td>
<td>追加元素到末尾</td>
</tr>
<tr>
<td>insert（）</td>
<td>在指定位置插入元素</td>
</tr>
<tr>
<td>pop()</td>
<td>删除list指定的元素</td>
</tr>
<tr>
<td>sort()</td>
<td>排序</td>
</tr>
</tbody></table>
</li>
<li><code>tuple</code>是初始化后不可变的有序列表，<code>(a,b,c)</code></li>
</ol>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown 的使用</title>
    <url>/2020/09/12/markdown-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用<code>#</code>号表示标题级数，共六级；</p>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>段落的换行是使用两个以上空格加上回车 或者 空行来表示重新开始一个段落</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>使用* 表示   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">**粗体文本**</span><br><span class="line">***斜体粗体文本***</span><br></pre></td></tr></table></figure>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个以上的***、—、__来建立一个分隔线</p>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>在文字的两端加上两个波浪线 ~~ 即可</p>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>通过 HTML 的 &lt;u&gt;   &lt;u&gt; 标签来实现</p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>[^要注明的文本]</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul>
<li>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容</li>
<li>有序列表使用数字并加上 . 号来表示</li>
<li>列表嵌套只需在子列表中的选项前面添加四个空格即可</li>
</ul>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><ul>
<li>在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</li>
<li>没嵌套一层区块，加一个&gt;<blockquote>
<p>test</p>
<blockquote>
<p>test</p>
<blockquote>
<p>test</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li><p>段落上的一个函数或片段的代码可以用反引号把它包起来（`）</p>
</li>
<li><p>代码区块</p>
<ul>
<li>使用 4 个空格或者一个制表符（Tab 键）</li>
<li>用 ``` 包裹一段代码，并指定一种语言（也可以不指定）</li>
</ul>
</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><code>[链接名称](链接地址)</code> 或者 <code>&lt;链接地址&gt;</code></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ul>
<li><code>![文本](地址)&quot;可选图片标题&quot;</code></li>
<li><code>&lt;img src=&quot;url&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;</code></li>
</ul>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul>
<li>制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行</li>
<li>设置表格的对齐方式<ul>
<li><code>-:</code>设置内容和标题栏居右对齐</li>
<li><code>:-</code>设置内容和标题栏居左对齐</li>
<li><code>:-:</code> 设置内容和标题栏居中对齐</li>
</ul>
</li>
</ul>
<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><ul>
<li>支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等</li>
<li>使用反斜杠转义特殊字符</li>
<li>插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现</li>
<li>画流程图、时序图(顺序图)、甘特图</li>
</ul>
<h1 id="Markdown-All-in-One"><a href="#Markdown-All-in-One" class="headerlink" title="Markdown All in One"></a>Markdown All in One</h1><p><img src="https://github.com/colawong/colawong.github.io/blob/master/source/_posts/markdown-%E7%9A%84%E4%BD%BF%E7%94%A8/%20table.png?raw=true" alt></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>cmd</kbd>+<kbd>b</kbd></td>
<td>粗体</td>
</tr>
<tr>
<td><kbd>cmd</kbd>+<kbd>i</kbd></td>
<td>斜体</td>
</tr>
<tr>
<td><kbd>cmd</kbd>+<kbd>shift</kbd>+<kbd>]</kbd></td>
<td>下级标题</td>
</tr>
<tr>
<td><kbd>cmd</kbd>+<kbd>shift</kbd>+<kbd>[</kbd></td>
<td>上级标题</td>
</tr>
<tr>
<td><kbd>cmd</kbd>+<kbd>m</kbd></td>
<td>数学模式</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>c</kbd></td>
<td>确认选项</td>
</tr>
<tr>
<td><kbd>alt</kbd>+<kbd>shift</kbd>+<kbd>f</kbd></td>
<td>表格对齐</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 的使用</title>
    <url>/2020/09/12/hexo-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>包括引用块、代码块、图片、网页等链接，具体使用参照<a href="https://hexo.io/zh-cn/docs/tag-plugins" title target>官方说明</a></p>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
